///////////////////////////////////// controlling motors with NRF24 //////////////////////////////////////////////////////////////////////////////////

//  uint8_t rxAddress[5] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
//  uint8_t channelNum = 10;
//  uint8_t rxPipe = 1;
//  uint8_t rxData[8];
//
//  nRF24Init();
//  nRF24RxMode(rxAddress, channelNum);

//  int map(uint32_t x, uint32_t in_min, uint32_t in_max, uint32_t out_min, uint32_t out_max) {
//	  returnVal = (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
//    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
//  }

//	  uint32_t xVal, yVal;
//	  if(isDataAvailable(rxPipe)) {
//		  nRF24Receive(rxData);
//		  xVal = (rxData[0] << 24 | rxData[1] << 16 | rxData[2] << 8 | rxData[3]);
//		  yVal = (rxData[4] << 24 | rxData[5] << 16 | rxData[6] << 8 | rxData[7]);
//		  HAL_IWDG_Refresh(&hiwdg);
//	  }
//
//
//	  if(xVal > 2200) {
//		  uint8_t mappedTimerVal = (xVal - 2200)/100 + 60;
//		  setAllMotors(mappedTimerVal);
//	  }
//	  else {
//		  setAllMotors(50);
//	  }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  MX_TIM1_Init();
  MX_UART4_Init();
  MX_SPI2_Init();
  MX_TIM16_Init();
  /* USER CODE BEGIN 2 */
  HAL_TIM_Base_Start(&htim16);

  uint8_t rxAddress[5] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  uint8_t channelNum = 10;
  uint8_t rxPipe = 1;
  uint8_t rxData[8];

  nRF24Init();
  nRF24RxMode(rxAddress, channelNum);

  float accelData[3], gyroData[3];
  float craftAngles[3] = {0, 0, 0};
  float desAngles[3] = {0, 0, 0};
  int16_t ctrlSignals[3] = {0, 0, 0};
  uint8_t rcThrottle[4];
  uint8_t motorThrottle[4];

  mpu6500Init();
  initializeAccelFilters();
  initializeMotors();
  MX_IWDG_Init();
  
	uint32_t xVal, yVal, mappedTimerVal;
	if(isDataAvailable(rxPipe)) {
		nRF24Receive(rxData);
	  	xVal = (rxData[0] << 24 | rxData[1] << 16 | rxData[2] << 8 | rxData[3]);
	  	yVal = (rxData[4] << 24 | rxData[5] << 16 | rxData[6] << 8 | rxData[7]);
	  	HAL_IWDG_Refresh(&hiwdg);
	}

	if(xVal > 2200) {
	  	mappedTimerVal = (xVal - 2200)/100 + 60;
	}
	else {
		mappedTimerVal = 50;
	}

  	rcThrottle[0] = mappedTimerVal;
  	rcThrottle[1] = mappedTimerVal;
  	rcThrottle[2] = mappedTimerVal;
  	rcThrottle[3] = mappedTimerVal;

	char buf[1000];

	updateCraftAngles(accelData, gyroData, craftAngles);
	rateController(gyroData, desAngles, ctrlSignals);
	actuateMotors(motorThrottle, rcThrottle, ctrlSignals);

	  //sprintf(buf, "%0.4f, %0.4f, %0.4f \r\n", accelData[0], accelData[1], accelData[2]);
//	  sprintf(buf, "%0.1f, %0.1f, %0.1f \r\n", gyroData[0], gyroData[1], gyroData[2]);
//	  sprintf(buf, "%0.1f, %0.1f, %0.1f \r\n",  craftAngles[0], craftAngles[1], craftAngles[2]);
//	  sprintf(buf, "%0.1f, %0.1f \r\n",  craftAngles[0], craftAngles[1]);
//	sprintf(buf, " FR: %hd, FL: %hd, RR: %hd, RL: %hd \r\n",  motorThrottle[0], motorThrottle[1], motorThrottle[2], motorThrottle[3]);

	motorSetSpeed(frontRightMotor, motorThrottle[0]);
	motorSetSpeed(frontLeftMotor, motorThrottle[1]);
	motorSetSpeed(rearRightMotor, motorThrottle[2]);
	motorSetSpeed(rearLeftMotor, motorThrottle[3]);

	if(craftAngles[0] > 30 || craftAngles[0] < -30) {
		setAllMotors(50);
		while(1) {}
	}
	if(craftAngles[1] > 30 || craftAngles[1] < -30) {
		setAllMotors(50);
		while(1) {}
	}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////